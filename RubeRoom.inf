!============================================================================
Constant Story "Rube  Room";
Constant Headline
    "^The Rube Room
    ^by Kian Ryan.^";
Release 1; Serial "201110";
! for keeping track of public releases
! Constant MAX_SCORE = 4;
Include "Parser";

replace FillSub;
Include "VerbLib";

!============================================================================
! Functions

! Toggle adjacent lanterns on or off.
[
    Toggle lantern;
    if (lantern has light) {
        give lantern ~light;
        lantern.short_name();
        print_ret " goes out!";
    }
    if (lantern hasnt light) {
        give lantern light;
        lantern.short_name();
        print_ret " bursts in to flames!";
    }
];

! Have all lanterns in a room been lit
[
    AllLit par a o;
    a = true;
    objectloop(o in par) {
        if (o ofclass Lantern && o hasnt light) {
            a = false;
        }
    }
    return a;
];

[
    Ordinal idx;
    switch (idx) {
        1: print "first";
        2: print "second";
        3: print "third";
        4: print "fourth";
        5: print "fifth";
        default: print idx, "th";
    }
    rtrue;
];

!============================================================================
! Object classes
Class Room
    with description "UNDER CONSTRUCTION",
    has light;

Class PuzzleRoom
    with description "UNDER CONSTRUCTION",
    with room_scored false,
    with win_description "ROOM HAS BEEN WON",
    with win_room [;
        ! Room may only be won once, even if
        ! objective is re-reached.
        if (self.room_scored == false) {
            self.room_scored = true;
            score = score + 1;
            self.win_description();
        }
        rtrue;
    ],
    has light;

Class Prop
    with description "WORKING ON IT",
    has scenery;

PuzzleRoom water_room "The Water Room"
    with description
        "You hear the water before you enter the room.  As you walk in to the
        room, you see the water falling from a waterfall in to a small rock
        pool below.",
    with win_description
        "The scale wobbles for a seconds and eventually settles perfectly balanced.";

Prop waterfall "Waterfall" water_room
    with name 'waterfall'
    with description
        "The water is coming from between the rocks in the darkness above
        and drops with a roaring flourish.  It's forcefull, but has an elegant
        calm to it.";

Attribute fillable; ! A container that can be filled
Attribute liquid; ! Contains an infinite liquid that can be used to fill a fillable

Prop rockpool "Rock Pool" water_room
    with name 'rock' 'pool' 'pond',
    with description
        "As you peer in to the rock pool you can't tell how deep it goes.  The
        light fades away in to nothingness.  What you can see is absolutely clear
        and beautiful.  There is no life in the pool.  The rocks are dark and
        volcanic, and would cut you in you ventured in."
    has liquid;

Class Amphora
    with name 'amphora' 'jug' 'bucket' 'vase',
        description [;
            print "A roman styled amphora.  It holds exactly ", self.volume, " litres.^";
            if (self.contents == 0)
                print_ret "You peer inside, there's not a drop to be seen.";
            if (self.contents >= self.volume)
                print_ret "The amphora is full to the brim.";
            else
                print_ret "Some liquid sloshes around inside, but you can't tell how much.";
        ],
        volume 5,
        contents 0,
   has fillable;

Amphora "large amphora" water_room
    with name 'large'
    with volume 5;

Amphora "small amphora" water_room
    with name 'small'
    with volume 3;

Object scale "scale" water_room
    with name 'scale' 'scales',
    with capacity 1,
    with description [weighing;
        print "A pair of elegant brass scales.^";
        weighing = child(self);
        if (weighing == nothing) print_ret "There is nothing on the scale";
        if (weighing.contents > self.balance) print_ret "The scale tips heavy";
        if (weighing.contents < self.balance) print_ret "The scale tips light";
        print_ret "The scale is perfectly balanced";
    ],
        balance 4,
        room_scored false,
        after [;
            Receive:
                if (noun hasnt fillable) {
                    move noun to player;
                    print_ret "That doesn't fit on the scales";
                }
                if (noun.contents > self.balance) print_ret "The scale wobbles and tips heavy.";
                if (noun.contents < self.balance) print_ret "The scale wobbles and tips light.";
                return parent(self).win_room();
        ],
   has static supporter;

! Puzzle description - Attempt to light the lantern with the match.
! If you light one lantern, the two adjacent go out.  The aim is to light
! All of the lanterns.

PuzzleRoom fire_room "The Fire Cave"
    with description "The walls are bare, but warm to the touch.  As you take a closer
    look at the walls, you realise the rock here is different, possibly volcanic.  You
    run your hand over and almost cut yourself on the sharp edges.  In the centre of the
    room are five lanterns in a line.";

Class Lantern
    with name 'lantern' 'lamp',
       short_name [;
           print (ordinal) self.index, " lantern";
           if (self has light) {
               print " (lit)";
           }
           return true;
       ],
       description [;
            print "A brass open cage holds an oiled wick.  You can smell the oil on the wick
            from a distance.^";
            if (self has light)
                print_ret "The lantern is lit with a modest flame that partially lights a
                section of the cave.  As the light dances, shadows play on the walls.";
            else
                print_ret "The lantern gives off no light.  It is warm to the touch and you
                can smell the oil on the wick.";
        ],
        before[;
        Burn:
            if (self has light) print_ret "Why, it's already lit?";
            if (match in player && second == match) {
                give self light;
                print "It takes a second, but the wick eventually takes the flame.^";
                Toggle(self.left);
                Toggle(self.right);

                if (AllLit(parent(self))) parent(self).win_room();
                rtrue;

            }
            print_ret "Light with what?";
        Snuff:
            if (self hasnt light) print_ret "Why, it's already out?";
            if (snuff in player && second == snuff) {
                give self ~light;
                print "You douse the flame, and room becomes a little darker.^";
                Toggle(self.left);
                Toggle(self.right);
                rtrue;
            }
            print_ret "Snuff with what?";
        ],

    has static;

! This may work with an array.

Lantern lantern1 fire_room
    with name 'first',
    with index 1,
    with left lantern5,
    with right lantern2;
Lantern lantern2 fire_room
    with name 'second',
    with index 2,
    with left lantern1,
    with right lantern3;
Lantern lantern3  fire_room
    with name 'third',
    with index 3,
    with left lantern2,
    with right lantern4;
Lantern lantern4 fire_room
    with name 'fourth',
    with index 4,
    with left lantern3,
    with right lantern5,
    has light;
Lantern lantern5 fire_room
    with name 'fifth',
    with index 5,
    with left lantern4,
    with right lantern1,
    has light;

! Magic match depends on if it's being held.
! It will not burn the user, but whilst being held, it will always be lit.
Object match "match" fire_room
    with name 'match',
    with description
        "It's a match.";

Object snuff "snuff" fire_room
    with name 'snuff' 'hood',
    with description
        "A plain brass snuff, with a long handle, used for extingusing lights.  The inside of the hood
        is sooted from use.";


!============================================================================
! Entry point routines
[ Initialise;
    location = fire_room;
    ! lookmode = 2;
    ! like the VERBOSE command
];


! Standard and extended grammar
Include "Grammar";
!============================================================================

Extend 'fill' replace
    * -> Fill
    * noun -> Fill
    * noun noun -> Fill
    * noun 'from'/'with' noun -> Fill;

[FillSub space available;
    if (noun == nothing) print_ret "What do you intend to fill?";
    if (second == nothing) print_ret "Where do you intend to fill from?";
    if (noun hasnt fillable) print_ret "How do you expect to fill that?";
    if (second hasnt liquid or fillable) print_ret "You can't fill from here.";

    if (second has fillable) {
        space = noun.volume - noun.contents;
        available = space;
        if (second.contents < space) available = second.contents;

        noun.contents = noun.contents + available;
        second.contents = second.contents - available;
    }
    else
        noun.contents = noun.volume;

    print_ret "You fill ", (the) noun, " from ", (the) second, ".";
];

[PourSub;
    if (noun == nothing) print_ret "What do you intend to pour?";
    if (noun hasnt fillable) print_ret "What do you intend to pour?";

    noun.contents = 0;
    print_ret "You pour the contents of ", (the) noun, " on to the ground.^
        It's now empty.";
];

Verb 'pour' 'spill'
    * -> Pour
    * noun -> Pour;

[SnuffSub;
    print_ret "Well, that doesn't need extinguising.";
];

Verb 'snuff' 'extinguish' 'put out' 'douse'
    * -> Snuff
    * noun -> Snuff
    * noun 'with'/'using' noun -> Snuff;



